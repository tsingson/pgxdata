package data
// This file is automatically generated by pgxdata.

import (
  "strings"

  "github.com/jackc/pgx"
  "github.com/jackc/pgx/pgtype"
)

type Semester struct {
  Year pgtype.Int2
  Season pgtype.Varchar
  Description pgtype.Text
}

const countSemesterSQL = `select count(*) from "semester"`

func CountSemester(db Queryer) (int64, error) {
  var n int64
  err := prepareQueryRow(db, "pgxdataCountSemester", countSemesterSQL).Scan(&n)
  return n, err
}

const SelectAllSemesterSQL = `select
  "year",
  "season",
  "description"
from "semester"`

func SelectAllSemester(db Queryer) ([]Semester, error) {
  var rows []Semester

  dbRows, err := prepareQuery(db, "pgxdataSelectAllSemester", SelectAllSemesterSQL)
  if err != nil {
    return nil, err
  }

  for dbRows.Next() {
    var row Semester
    dbRows.Scan(
&row.Year,
    &row.Season,
    &row.Description,
    )
    rows = append(rows, row)
  }

  if dbRows.Err() != nil {
    return nil, dbRows.Err()
  }

  return rows, nil
}

const selectSemesterByPKSQL = `select
  "year",
  "season",
  "description"
from "semester"
where "year"=$1 and "season"=$2`

func SelectSemesterByPK(
  db Queryer,
  year int16,
  season string,
) (*Semester, error) {
  var row Semester
  err := prepareQueryRow(db, "pgxdataSelectSemesterByPK", selectSemesterByPKSQL, year, season).Scan(
&row.Year,
    &row.Season,
    &row.Description,
    )
  if err == pgx.ErrNoRows {
    return nil, ErrNotFound
  } else if err != nil {
    return nil, err
  }

  return &row, nil
}

func InsertSemester(db Queryer, row *Semester) error {
  args := pgx.QueryArgs(make([]interface{}, 0, 3))

  var columns, values []string

  if row.Year.Status != pgtype.Undefined {
    columns = append(columns, `year`)
    values = append(values, args.Append(&row.Year))
  }
  if row.Season.Status != pgtype.Undefined {
    columns = append(columns, `season`)
    values = append(values, args.Append(&row.Season))
  }
  if row.Description.Status != pgtype.Undefined {
    columns = append(columns, `description`)
    values = append(values, args.Append(&row.Description))
  }


  sql := `insert into "semester"(` + strings.Join(columns, ", ") + `)
values(` + strings.Join(values, ",") + `)
returning "year", "season"
  `

  psName := preparedName("pgxdataInsertSemester", sql)

  return prepareQueryRow(db, psName, sql, args...).Scan(&row.Year, &row.Season)
}

func UpdateSemester(db Queryer,
  year int16,
  season string,
  row *Semester,
) error {
  sets := make([]string, 0, 3)
  args := pgx.QueryArgs(make([]interface{}, 0, 3))

  if row.Year.Status != pgtype.Undefined {
    sets = append(sets, `year`+"="+args.Append(&row.Year))
  }
  if row.Season.Status != pgtype.Undefined {
    sets = append(sets, `season`+"="+args.Append(&row.Season))
  }
  if row.Description.Status != pgtype.Undefined {
    sets = append(sets, `description`+"="+args.Append(&row.Description))
  }


  if len(sets) == 0 {
    return nil
  }

  sql := `update "semester" set ` + strings.Join(sets, ", ") + ` where `  + `"year"=` + args.Append(year) + ` and "season"=` + args.Append(season)

  psName := preparedName("pgxdataUpdateSemester", sql)

  commandTag, err := prepareExec(db, psName, sql, args...)
  if err != nil {
    return err
  }
  if commandTag.RowsAffected() != 1 {
    return ErrNotFound
  }
  return nil
}

func DeleteSemester(db Queryer,
  year int16,
  season string,
) error {
  args := pgx.QueryArgs(make([]interface{}, 0, 2))

  sql := `delete from "semester" where `  + `"year"=` + args.Append(year) + ` and "season"=` + args.Append(season)

  commandTag, err := prepareExec(db, "pgxdataDeleteSemester", sql, args...)
  if err != nil {
    return err
  }
  if commandTag.RowsAffected() != 1 {
    return ErrNotFound
  }
  return nil
}

