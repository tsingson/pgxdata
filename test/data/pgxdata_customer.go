package data
// This file is automatically generated by pgxdata.

import (
  "strings"

  "github.com/jackc/pgx"
  "github.com/jackc/pgx/pgtype"
)

type Customer struct {
  ID pgtype.Int4
  FirstName pgtype.Varchar
  LastName pgtype.Varchar
  BirthDate pgtype.Date
  CreationTime pgtype.Timestamptz
}

const countCustomerSQL = `select count(*) from "customer"`

func CountCustomer(db Queryer) (int64, error) {
  var n int64
  err := prepareQueryRow(db, "pgxdataCountCustomer", countCustomerSQL).Scan(&n)
  return n, err
}

const SelectAllCustomerSQL = `select
  "id",
  "first_name",
  "last_name",
  "birth_date",
  "creation_time"
from "customer"`

func SelectAllCustomer(db Queryer) ([]Customer, error) {
  var rows []Customer

  dbRows, err := prepareQuery(db, "pgxdataSelectAllCustomer", SelectAllCustomerSQL)
  if err != nil {
    return nil, err
  }

  for dbRows.Next() {
    var row Customer
    dbRows.Scan(
&row.ID,
    &row.FirstName,
    &row.LastName,
    &row.BirthDate,
    &row.CreationTime,
    )
    rows = append(rows, row)
  }

  if dbRows.Err() != nil {
    return nil, dbRows.Err()
  }

  return rows, nil
}

const selectCustomerByPKSQL = `select
  "id",
  "first_name",
  "last_name",
  "birth_date",
  "creation_time"
from "customer"
where "id"=$1`

func SelectCustomerByPK(
  db Queryer,
  id int32,
) (*Customer, error) {
  var row Customer
  err := prepareQueryRow(db, "pgxdataSelectCustomerByPK", selectCustomerByPKSQL, id).Scan(
&row.ID,
    &row.FirstName,
    &row.LastName,
    &row.BirthDate,
    &row.CreationTime,
    )
  if err == pgx.ErrNoRows {
    return nil, ErrNotFound
  } else if err != nil {
    return nil, err
  }

  return &row, nil
}

func InsertCustomer(db Queryer, row *Customer) error {
  args := pgx.QueryArgs(make([]interface{}, 0, 5))

  var columns, values []string

  if row.ID.Status != pgtype.Undefined {
    columns = append(columns, `id`)
    values = append(values, args.Append(&row.ID))
  }
  if row.FirstName.Status != pgtype.Undefined {
    columns = append(columns, `first_name`)
    values = append(values, args.Append(&row.FirstName))
  }
  if row.LastName.Status != pgtype.Undefined {
    columns = append(columns, `last_name`)
    values = append(values, args.Append(&row.LastName))
  }
  if row.BirthDate.Status != pgtype.Undefined {
    columns = append(columns, `birth_date`)
    values = append(values, args.Append(&row.BirthDate))
  }
  if row.CreationTime.Status != pgtype.Undefined {
    columns = append(columns, `creation_time`)
    values = append(values, args.Append(&row.CreationTime))
  }


  sql := `insert into "customer"(` + strings.Join(columns, ", ") + `)
values(` + strings.Join(values, ",") + `)
returning "id"
  `

  psName := preparedName("pgxdataInsertCustomer", sql)

  return prepareQueryRow(db, psName, sql, args...).Scan(&row.ID)
}

func UpdateCustomer(db Queryer,
  id int32,
  row *Customer,
) error {
  sets := make([]string, 0, 5)
  args := pgx.QueryArgs(make([]interface{}, 0, 5))

  if row.ID.Status != pgtype.Undefined {
    sets = append(sets, `id`+"="+args.Append(&row.ID))
  }
  if row.FirstName.Status != pgtype.Undefined {
    sets = append(sets, `first_name`+"="+args.Append(&row.FirstName))
  }
  if row.LastName.Status != pgtype.Undefined {
    sets = append(sets, `last_name`+"="+args.Append(&row.LastName))
  }
  if row.BirthDate.Status != pgtype.Undefined {
    sets = append(sets, `birth_date`+"="+args.Append(&row.BirthDate))
  }
  if row.CreationTime.Status != pgtype.Undefined {
    sets = append(sets, `creation_time`+"="+args.Append(&row.CreationTime))
  }


  if len(sets) == 0 {
    return nil
  }

  sql := `update "customer" set ` + strings.Join(sets, ", ") + ` where `  + `"id"=` + args.Append(id)

  psName := preparedName("pgxdataUpdateCustomer", sql)

  commandTag, err := prepareExec(db, psName, sql, args...)
  if err != nil {
    return err
  }
  if commandTag.RowsAffected() != 1 {
    return ErrNotFound
  }
  return nil
}

func DeleteCustomer(db Queryer,
  id int32,
) error {
  args := pgx.QueryArgs(make([]interface{}, 0, 1))

  sql := `delete from "customer" where `  + `"id"=` + args.Append(id)

  commandTag, err := prepareExec(db, "pgxdataDeleteCustomer", sql, args...)
  if err != nil {
    return err
  }
  if commandTag.RowsAffected() != 1 {
    return ErrNotFound
  }
  return nil
}

